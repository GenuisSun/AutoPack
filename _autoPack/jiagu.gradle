import groovy.json.JsonSlurper

apply plugin: 'de.undercouch.download'
/**
 * @Author: stc @Date: 2020/6/14
 * @email: dearstc@163.com
 *
 * ❤-- 使用360加固版本 3.2.2.3 2020-03-16 --❤
 *
 *
 * ❤❤❤----------------------------------------------------------------❤❤❤
 * ❤❤❤--TODO  Task:_autoPack
 * ❤❤❤--  一键打包--下载加固资源文件-360加固-瓦力打渠道包
 * ❤❤❤--  方法一 执行gradle窗口中分组_autoPack下的_autoPack任务即可
 * ❤❤❤--  方法二 Terminal窗口执行(powershell)-->gradle _autoPack
 * ❤❤❤--                            (linux)-->./gradle _autoPack
 * ❤❤❤--        注：前提是配置了gradle的环境变量
 * ❤❤❤--  多平台支持mac/windows/linux
 * ❤❤❤--  声明多个Task是为了方便在执行流程中，更清晰的查阅到执行到那个任务
 * ❤❤❤--  加固文件资源默认是不存在，自动从官网下载，无需特意操作
 * ❤❤❤--  注：❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤
 * ❤❤❤--  注：❤❤❤❤❤❤❤❤❤因为要下载文件到本地  故项目不要放在高权限的目录❤❤❤❤❤❤❤❤❤
 * ❤❤❤--  注：❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤
 * ❤❤❤--  最终渠道包路径请查看打包流程日志，写的很清楚了。
 * ❤❤❤--
 * ❤❤❤--TODO  Task:assembleBetaTo*** / assembleReleaseTo***
 * ❤❤❤--  打包完成上传蒲公英/Fir的Task  依赖于assembleBeta打包
 * ❤❤❤--  assembleBeta打包完成自动上传到蒲公英 输出相关信息  打开短链接
 * ❤❤❤-----------------------------------------------------------------❤❤❤
 * */

/**
 * 360加固文件所在的文件夹名字
 */
def folder_name = "_autoPack"

/**
 * 项目根路径的决定路径
 */
def projectPath = getRootDir().getAbsolutePath()

getRootProject().ext.jiaguConfig = [

        //360 账号 (必须)
        "_360_user_name"         : rootProject.ext._360["account"],
        "_360_user_pw"           : rootProject.ext._360["password"],

        //签名文件配置, 使用空字符, 会自动赋值. (可选)
        "keystorePath"           : '',
        "keystorePwd"            : '',
        "keystoreAlias"          : '',
        "keystoreAliasPwd"       : '',

        //需要加固的APK路径, 如果不存在任务中断执行, 为空:自动根据Gradle配置获取路径 (可选)
        "targetApkPath"          : "",

        //自动查找`targetApkPath`时, 取名字中包含`likeApkName`字符串的路径, 如果有多个, 取第一个
        "likeApkName"            : "",

        //文件所在的根目录
        "root_path"              : projectPath + "/" + folder_name,
        //首次下载360加固的临时存放目录
        "download_jiagu_path"    : projectPath + "/" + folder_name + "/tempdownload",
        //下载360加固包的全路径
        "download_jiagu_zip_path": projectPath + "/" + folder_name + "/tempdownload/360jiagubao.zip",

        //360加固文件所在的根目录
        "jiagu_root_path"        : projectPath + "/" + folder_name + "/jiagu",
        "walle_root_path"        : projectPath + "/" + folder_name + "/walle",

        //渠道文件信息路径
        "channelList"            : projectPath + "/" + folder_name + "/walle/channel",

        //渠道分包后的APK文件名,为空:自动从Gradle脚本中获取 (可选)
        "tmpApkName"             : "",

        //最终生成zip包的文件名 (可选)
        "zipFileName"            : "",

        //360加固jar文件路径
        "jiaguJarPath"           : projectPath + "/" + folder_name + "/jiagu/jiagu.jar",
        //walle分包jar文件路径
        "walleJarPath"           : projectPath + "/" + folder_name + "/walle/walle-cli-all.jar",
        //临时文件输出目录
        "tmpOutput"              : projectPath + "/" + folder_name + "/output/tmp",
        //zip文件输出目录
        "zipOutput"              : projectPath + "/" + folder_name + "/output/zip",
        //加固后文件输出目录
        "jiaguOutput"            : projectPath + "/" + folder_name + "/output/jiagu",
        //walle分包输出目录
        "walleOutput"            : projectPath + "/" + folder_name + "/output/walle",

        //todo 360加固保 首次配置自动下载  下方链接为官方链接，如官方有改动  可改
        //加固mac下载地址
        "jiagubao_mac"           : "https://down.360safe.com/360Jiagu/360jiagubao_mac.zip",
        //加固widnows下载地址
        "jiagubao_windows"       : "https://down.360safe.com/360Jiagu/360jiagubao_windows_64.zip",
        //加固linux下载地址
        "jiagubao_linux"         : "https://down.360safe.com/360Jiagu/360jiagubao_linux_64.zip"

]
//❤❤❤❤❤❤start❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤
/**
 * 把声明的 常用打包任务 都转移到_autoPack分组中
 * 并为该任务设置依赖clean关系  即每次自动删除build文件夹
 */
project.afterEvaluate {
    project.android.applicationVariants.all { variant ->
        def pack = 'assemble' + variant.name.capitalize()
        if (null != project.tasks.findByPath(pack) && folder_name != project.tasks.getByName(pack).getGroup()) {
            project.tasks.getByName(pack).setGroup(folder_name)
            project.tasks.getByName(pack).dependsOn('clean')
        }
    }
}

// 输出执行任务名 用于调试
//gradle.taskGraph.beforeTask { Task task ->
//    println "executing $task ..."
//}
//❤❤❤❤❤❤end❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤


//❤❤❤❤❤❤start打包流程❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤
/**
 * 根据系统下载相应的360加固资源包
 */
task downloadZipFile(dependsOn: 'assembleRelease') {
    //先判断本地有没有加固文件夹，一般项目第一次clone下来的时候都是不存在的
    //首次需自动下载
    File folder = file(jiaguConfig.jiagu_root_path)
    File file = file(jiaguConfig.jiaguJarPath)
    //enabled属性---是否跳过当前任务
    enabled = !(folder.exists() && file.exists())
    doFirst {
        color_print "执行assembleRelease打包任务完毕"
        if (!enabled) {
            color_print "360加固文件夹 和 加固jar文件存在"
        } else {
            color_print "360加固文件夹或者加固jar文件不存在，为该系统本地下载相关资源包"
        }
    }
    doLast {
        //TODO 方法一：使用de.undercouch.download 下载资源
//        download {
//            src getJiaGuZipUrlByOs()
//            dest new File(jiaguConfig.download_jiagu_zip_path)
//            overwrite false
//        }
        //TODO 方法二：使用系统curl命令 下载资源 目前测试window10 mac正常支持
        File zipFile = new File(jiaguConfig.download_jiagu_zip_path)
        if (!zipFile.exists()) {
            if (!zipFile.parentFile.exists()) {
                zipFile.parentFile.mkdirs()
            }
            def downloadUrl = getJiaGuZipUrlByOs()
            def cmd = "curl -o ${jiaguConfig.download_jiagu_zip_path} ${downloadUrl}"
            cmd.execute().waitForProcessOutput(System.out, System.err)
        }
        color_print "360加固资源包下载完成 路径在" + jiaguConfig.download_jiagu_zip_path
        color_print "执行解压任务 ❤unzipFile❤ 请稍后。。。"
    }
}

/**
 * 解压下载的加固包
 */
task unzipFile(dependsOn: downloadZipFile, type: Copy) {
    //onlyIf属性进行条件判断，判断当前任务是否执行
    onlyIf { downloadZipFile.enabled }
    from zipTree(jiaguConfig.download_jiagu_zip_path)
    into jiaguConfig.download_jiagu_path
    doLast {
        File folder = file(jiaguConfig.download_jiagu_path)
        for (File f : folder.listFiles()) {
            color_print "解压成功:" + f
        }
        color_print "全部解压完成  准备将解压出来的jiagu文件夹复制到" + jiaguConfig.root_path + "文件夹下"
        color_print "执行复制任务 ❤copyDownloadJiaGu❤ 请稍后。。。"
    }
}

/**
 * 复制解压下载的加固包中的jiagu文件夹到配置文件夹
 */
task copyDownloadJiaGu(dependsOn: unzipFile) {
    onlyIf { downloadZipFile.enabled }
    //下载的360加固zip解压出的jiagu文件家路径
    def downnload_jiagu = jiaguConfig.download_jiagu_path + "/jiagu"
    doFirst {
        File folder = file(downnload_jiagu)
        if (!folder.exists()) {
            File file1 = new File(jiaguConfig.download_jiagu_path)
            if (file1.exists()) {
                color_print "删除资源下载临时目录：" + file1 + "   " + file1.deleteDir()
            }
            File file2 = new File(jiaguConfig.jiagu_root_path)
            if (file2.exists()) {
                color_print "删除创建的jiagu文件夹：" + file2 + "   " + file2.deleteDir()
            }
            throw new RuntimeException("没有在解压的文件夹中找到jiagu文件夹，请重试 或者 手动官网下载相关360加固文件，将资源包中的jiagu文件夹解压到：" + jiaguConfig.root_path + "文件夹下")
        }
        copy {
            from downnload_jiagu
            into jiaguConfig.jiagu_root_path
        }
    }
    doLast {
        color_print "复制完成。。。copy " + downnload_jiagu + " to " + jiaguConfig.jiagu_root_path
        File filedir = new File(jiaguConfig.download_jiagu_path)
        color_print "删除下载的资源临时存放文件夹：" + filedir + "   " + filedir.deleteDir()
        color_print "下载加固资源流程结束,开始进行360加固。。。"

    }
}


/**
 * 进行登录
 */
task login(type: JavaExec, dependsOn: copyDownloadJiaGu) {
    workingDir(jiaguConfig.jiagu_root_path)
    classpath(files(jiaguConfig.jiaguJarPath))
    main('com.qihoo.jiagu.CmdMain')
    args('-login', jiaguConfig._360_user_name, jiaguConfig._360_user_pw)
}

/**
 * 登录前（2） 进行相关文件夹的创建和清空
 */
login.doFirst {
    File targetFile = new File(jiaguConfig.targetApkPath)
    if (!targetFile.exists()) {
        throw new RuntimeException("加固apk文件不存在:" + targetFile.getAbsolutePath())
    } else {
        color_print("开始加固:" + targetFile.getAbsolutePath())
        color_print("输出渠道包zip路径:" + jiaguConfig.zipOutput)
    }
    //创建基础文件夹
    createFolder(jiaguConfig.walleOutput, true)
    createFolder(jiaguConfig.zipOutput)
    createFolder(jiaguConfig.jiaguOutput, true)
    createFolder(jiaguConfig.tmpOutput, true)
    checkZipFolderNum(jiaguConfig.zipOutput)
}

/**
 * 登录前（1）初始化相关路径信息  签名信息
 */
login.doFirst {
    project.android.applicationVariants.all { variant ->
        //对应app/build.gradle文件声明 buildTypes 下声明的打包类型
        if (
        (jiaguConfig.likeApkName == "" && variant.name.toLowerCase() == "release")
                || (jiaguConfig.likeApkName != "" && variant.name.toLowerCase().contains(jiaguConfig.likeApkName))
        ) {
            color_print("初始化相关路径信息  签名信息，当前打包方式：" + variant.name.toLowerCase())
            if (jiaguConfig.keystorePath == '') {
                //自动配置签名信息
                jiaguConfig.keystorePath = variant.signingConfig.storeFile
                jiaguConfig.keystorePwd = variant.signingConfig.storePassword
                jiaguConfig.keystoreAlias = variant.signingConfig.keyAlias
                jiaguConfig.keystoreAliasPwd = variant.signingConfig.keyPassword


                List<String> list = new ArrayList<>()
                list.add('-importsign')
                list.add(jiaguConfig.keystorePath)
                list.add(jiaguConfig.keystorePwd)
                list.add(jiaguConfig.keystoreAlias)
                list.add(jiaguConfig.keystoreAliasPwd)

                color_print "使用签名:" + list

                setKeystore.setArgs(list)
            }

            variant.outputs.each { output ->
                //自动配置目标文件路径, 和临时文件名
                if (jiaguConfig.targetApkPath == "") {
                    jiaguConfig.targetApkPath = output.outputFile.getAbsolutePath()
                    color_print "读取到目标apk路径:" + jiaguConfig.targetApkPath
                }

                if (jiaguConfig.tmpApkName == '') {
                    jiaguConfig.tmpApkName = output.outputFile.getName()
                    color_print "临时文件名:" + jiaguConfig.tmpApkName
                }
                copyTmpApk.rename('(.+)', jiaguConfig.tmpApkName)

                if (jiaguConfig.zipFileName == '') {
                    jiaguConfig.zipFileName = jiaguConfig.tmpApkName
                            .substring(0, jiaguConfig.tmpApkName.lastIndexOf('.')) + "_channel.zip"
                    color_print "zip文件名:" + jiaguConfig.zipFileName
                }

                zipChannel.archiveName = jiaguConfig.zipFileName

                //重置加固task参数
                List<String> list = new ArrayList<>()
                list.add('-jiagu')
                list.add(jiaguConfig.targetApkPath)
                list.add(jiaguConfig.jiaguOutput)
                list.add('-autosign')
                jiagu360.setArgs(list)

                //重置walle task参数
                list = new ArrayList<>()
                list.add('batch')
                list.add('-f')
                list.add(jiaguConfig.channelList)
                list.add(jiaguConfig.tmpOutput + File.separator + jiaguConfig.tmpApkName)
                list.add(jiaguConfig.walleOutput)
                walleApk.setArgs(list)
            }
        }
    }
}

/**
 * 设置签名配置
 */
task setKeystore(type: JavaExec, dependsOn: login) {
    workingDir(jiaguConfig.jiagu_root_path)
    classpath(files(jiaguConfig.jiaguJarPath))
    main('com.qihoo.jiagu.CmdMain')
}

/**
 * 显示签名信息
 */
task showKeystore(type: JavaExec) {
    workingDir(jiaguConfig.jiagu_root_path)
    classpath(files(jiaguConfig.jiaguJarPath))
    main('com.qihoo.jiagu.CmdMain')
    args('-showsign')
}

/**
 * 进行加固
 */
task jiagu360(type: JavaExec, dependsOn: setKeystore) {
    workingDir(jiaguConfig.jiagu_root_path)
    classpath(files(jiaguConfig.jiaguJarPath))
    main('com.qihoo.jiagu.CmdMain')
}


/**
 * 加固后的包保留,拷贝一份在tmp里面
 */
task copyTmpApk(type: Copy, dependsOn: jiagu360) {
    from(jiaguConfig.jiaguOutput)
    include('*.apk')
    into(jiaguConfig.tmpOutput)
}

/**
 * 瓦力打渠道包
 */
task walleApk(type: JavaExec, dependsOn: copyTmpApk) {
    workingDir(jiaguConfig.walle_root_path)
    classpath(files(jiaguConfig.walleJarPath))
    main('com.meituan.android.walle.Main')
}

/**
 * 瓦力将渠道包打压缩包
 */
task zipChannel(type: Zip, dependsOn: walleApk) {
    //workingDir(baseBuildPath)
    from(jiaguConfig.walleOutput)
    //动态设置
    archiveName(jiaguConfig.zipFileName)
    destinationDir file(jiaguConfig.zipOutput)
}

/**
 * 主任务===》 一键打包--下载加固资源文件-360加固-瓦力打渠道包
 */
task _autoPack(dependsOn: zipChannel, description: '一键打包--下载加固资源文件-360加固-瓦力打渠道包') {
    group folder_name
    doLast {
        color_print "加固打包流程结束:"
        color_printSuccess("渠道包路径:" + jiaguConfig.walleOutput)
        color_printSuccess("zip包路径:" + jiaguConfig.zipOutput)
    }
}

/**
 * 创建路径
 */
def createFolder(String path, boolean clear = false) {
    File folder = file(path)
    if (folder.exists()) {
        if (clear) {
            clearFolder(path)
        }
    } else {
        folder.mkdirs()
    }
}

/**
 * 清理文件夹
 */
def clearFolder(String path) {
    File folder = file(path)
    for (File f : folder.listFiles()) {
        if (f.isDirectory()) {
            clearFolder(f.getAbsolutePath())
        } else if (f.isFile()) {
            color_print "删除文件:" + f + " " + f.delete()
        }
    }
}

/**
 * 检测渠道zip文件夹下压缩包数量，避免过多本地存储
 * 目前设置最多存储五次渠道包历史
 * @param path
 */
def checkZipFolderNum(def path) {
    //文件路径
    List<File> list = getFileSort(path)
    for (int i = 0; i < list.size(); i++) {
        if (i >= 5) {
            color_print "删除历史渠道zip包:" + list.get(i).getName() + " " + list.get(i).delete()
        }
    }
}

/**
 * 获取目录下所有文件(按时间排序)
 *
 * @param path
 * @return
 */
def getFileSort(String path) {

    List<File> list = getFiles(path, new ArrayList<File>())

    if (list != null && list.size() > 0) {

        Collections.sort(list, new Comparator<File>() {
            @Override
            int compare(File file, File newFile) {
                if (file.lastModified() < newFile.lastModified()) {
                    return 1
                } else if (file.lastModified() == newFile.lastModified()) {
                    return 0
                } else {
                    return -1
                }
            }
        })
    }

    return list
}
/**
 * 获取目录下所有文件
 * @param realpath
 * @param files
 * @return
 */
def getFiles(String realpath, List<File> files) {
    File realFile = new File(realpath)
    if (realFile.isDirectory()) {
        File[] subfiles = realFile.listFiles()
        for (File file : subfiles) {
            if (file.isDirectory()) {
                getFiles(file.getAbsolutePath(), files)
            } else {
                files.add(file)
            }
        }
    }
    return files
}

/**
 * 获取当前操作系统的360加固资源下载链接
 */
def getJiaGuZipUrlByOs() {
    def url
    String osName = org.gradle.internal.os.OperatingSystem.current().getName();
    String osVersion = org.gradle.internal.os.OperatingSystem.current().getVersion();
    color_print "当前使用系统 $osName $osVersion was detected."

    if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        url = jiaguConfig.jiagubao_linux
    } else if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        url = jiaguConfig.jiagubao_windows
    } else if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        url = jiaguConfig.jiagubao_mac
    } else {
        throw new RuntimeException("不支持当前操作系统：" + osName)
    }
    color_print "对应要下载360加固包的链接地址为：" + url
    return url
}

//❤❤❤❤❤❤end打包流程❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤


//❤❤❤❤❤❤start蒲公英/fir❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤

/**
 * 打测试包并上传到蒲公英
 */
task assembleBetaToPGY(dependsOn: 'assembleBeta', description: '打测试包并上传到蒲公英') {
    group folder_name
    doLast {
        _uploadApp('beta', false)
    }
}

/**
 * 打正式包并上传到蒲公英
 */
task assembleReleaseToPGY(dependsOn: 'assembleRelease', description: '打正式包并上传到蒲公英') {
    group folder_name
    doLast {
        _uploadApp('release', false)
    }
}
/**
 * 打测试包并上传到fir
 */
task assembleBetaToFir(dependsOn: 'assembleBeta', description: '打测试包并上传到Fir') {
    group folder_name
    doLast {
        _uploadApp('beta', true)
    }
}

/**
 * 打正式包并上传到fir
 */
task assembleReleaseToFir(dependsOn: 'assembleRelease', description: '打正式包并上传到Fir') {
    group folder_name
    doLast {
        _uploadApp('release', true)
    }
}

/**
 * 上传apk至蒲公英前进行路径文件检查
 */
def _uploadApp(String name, boolean fir) {
    project.outgoingVariants.
            project.android.applicationVariants.all { variant ->
        //对应app/build.gradle文件声明 buildTypes 下声明的打包类型
        if (variant.name.toLowerCase().endsWith(name)) {
            variant.outputs.each { output ->
                color_print "上传" + (fir ? " fir平台 " : " 蒲公英平台 ") + "的apk路径:" + output.outputFile.getAbsolutePath()
                File dir = new File(output.outputFile.getAbsolutePath())
                if (!dir.exists()) {
                    throw new RuntimeException("目标apk路径 not exists：" + dir.path)
                }
                if (fir) {
                    //上传fir
                    uploadFir(dir.path)
                } else {
                    //上传蒲公英
                    uploadPGY(dir.path)
                }
            }
        }
    }

}

/**
 * 上传apk到蒲公英
 */
private def uploadPGY(String filePath) {
    def stdout = new ByteArrayOutputStream()
    exec {
        executable = 'curl'
        args = ['-F', "file=@${filePath}",
                '-F', "uKey=${rootProject.ext.pgy["uKey"]}",
                '-F', "_api_key=${rootProject.ext.pgy["apiKey"]}",
                rootProject.ext.pgy["uploadUrl"]]
        standardOutput = stdout
    }
    String output = stdout.toString()
//    color_print(output)
    def parsedJson = new JsonSlurper().parseText(output)
    color_printSuccess "👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙上传成功👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙"
    color_printSuccess "App的安装包名称：" + parsedJson.data.buildFileName
    color_printSuccess "App版本名称：" + parsedJson.data.buildVersion
    color_printSuccess "App版本号：" + parsedJson.data.buildVersionNo
    color_printSuccess "AppBuildVersion：" + parsedJson.data.buildBuildVersion
    color_printSuccess "App包体积：" + parsedJson.data.buildFileSize
    color_printSuccess "App下载页地址：https://www.pgyer.com/" + parsedJson.data.buildShortcutUrl
//    color_printSuccess "App二维码地址：" + parsedJson.data.buildQRCodeURL
    color_printSuccess "App上传时间：" + parsedJson.data.buildCreated
    color_printSuccess "👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙信息打印完毕👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙"
    openBrowser("https://www.pgyer.com/" + parsedJson.data.buildShortcutUrl)
}


/**
 * 上传apk到fir
 * @param filePath
 * @return
 */
def uploadFir(String filePath) {
    //fir api_token
    def FIR_API_TOKEN = rootProject.ext.fir["apiToken"]
    //packageName fir上应用的包名
    def packageName = project.android.defaultConfig.applicationId
    //获取fir上传凭证的各个字段
    def appInfo = ("curl -X POST -d type=android&bundle_id=$packageName&api_token=$FIR_API_TOKEN http://api.fir.im/apps").execute().text

//    color_print(appInfo.toString())
    //json解析对象拿到的是Map, 集合对应的是array, 按照这个规则取出我们需要的数据
    def appInfoBean = new JsonSlurper().parseText(appInfo)
    //短链接
    def buildShortcutUrl = "http://" + appInfoBean["download_domain"] + "/" + appInfoBean["short"]
    //应用id 用来修改应用信息
    def id = appInfoBean["id"]

    File file = file(rootProject.ext.fir["appIcon"])
    if (file.exists()) {
        //上传应用icon
        def uploadIcon = new ByteArrayOutputStream()
        exec {
            executable = 'curl'
            args = ['-F', "file=@${rootProject.ext.fir["appIcon"]}",
                    '-F', "token=${appInfoBean["cert"]["icon"]["token"]}",
                    '-F', "key=${appInfoBean["cert"]["icon"]["key"]}",
                    appInfoBean["cert"]["icon"]["upload_url"]]
            standardOutput = uploadIcon
        }
        color_print("应用icon上传结果(无影响，非必要)：" + uploadIcon.toString())
    } else {
        color_printError("应用icon文件不存在(无影响，非必要)：若需要，请检查全局变量fir的appIcon设置的路径图片是否存在")
    }

    //上传apk文件
    def upload = ("curl -X POST --form file=@$filePath" +
            " -F token=${appInfoBean["cert"]["binary"]["token"]}" +
            " -F key=${appInfoBean["cert"]["binary"]["key"]}" +
            " -F x:version=$project.android.defaultConfig.versionName" +
            " -F x:build=$project.android.defaultConfig.versionCode" +
            " -F x:changelog=123456" +
            " ${appInfoBean["cert"]["binary"]["upload_url"]}").execute().text

//    color_print upload.toString()
    try {
        def uploadResult = new JsonSlurper().parseText(upload)
        if (uploadResult.is_completed) {
            //修改app应用名称 如果在直接上传里面设置appname会中文乱码，故需要重新走一下修改信息  官方未解释原因
            def appName = URLEncoder.encode(rootProject.ext.fir["appName"])
            def updateInfo = ("curl -X PUT -d name=$appName -d api_token=$FIR_API_TOKEN http://api.bq04.com/apps/$id").execute().text
//            color_print(updateInfo.toString())
            color_printSuccess "👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙上传成功👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙"
            color_printSuccess ""
            color_printSuccess ""
            color_printSuccess "     fir下载短链接为：" + buildShortcutUrl
            color_printSuccess ""
            color_printSuccess ""
            color_printSuccess "👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙信息打印完毕👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙👙"
            openBrowser(buildShortcutUrl)
        } else {
            color_printError "apk上传失败"
        }
    } catch (Exception e) {
        color_printError "apk上传失败"
    }
}

def openBrowser(String url) {
    //打开短链接
    exec {
        if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
            commandLine "x-www-browser", url
        } else if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            commandLine "powershell", "start", url
        } else if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
            commandLine "open", url
        }
    }
}

//❤❤❤❤❤❤-----end蒲公英/fir-----❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤

/**
 * 彩色日志打印
 * printf("\033[字背景颜色;字体颜色m 字符串 \033[0m" );
 * @param value
 * @return
 */
def color_print(String value) {
    printf "\033[1;33m🚶🏃🚶🏃🚶🏃🚶🏃\t%s\033[0m\n", value
}

def color_printSuccess(String value) {
    printf "\033[1;32m👙👙👙👙\t%s\033[0m\n", value
}

def color_printError(String value) {
    printf "\033[1;31m💀💀💀💀\t%s\033[0m\n", value
}
