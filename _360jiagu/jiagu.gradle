import groovy.json.JsonSlurper
apply plugin: 'de.undercouch.download'
/**
 * Author: stc
 * Date:   2020/6/14
 *         ❤-- 使用360加固版本 3.2.2.3 2020-03-16 --❤
 *         ❤-- 如果出现,签名配置中没有匹配的签名,请使用命令行的方式单独导入签名信息. --❤
 *         ❤-- java -jar jiagu.jar  -importsign<keystore_path><keystore_password><alias><alias_password> --❤
 *         ❤-- 这有可能是360加固的BUG --❤
 *         ❤-- TODO 此文件 声明多个task是为了方便在执行流程中，更清晰的查阅到执行到那个任务 --❤
 *         ❤-- TODO 如需配置win mac 外的其他平台，请下载先关360加固文件 解压之后:将`java`文件夹 放在 `jiagu/` 文件夹下，并重命名. --❤
 **/

//360加固文件所在的文件夹名字
def folder_name = "_360jiagu"
//项目根路径的决定路径
def projectPath = getRootDir().getAbsolutePath()

getRootProject().ext.jiaguConfig = [

        //360 账号 (必须)
        "_360_user_name"     : project.ACCOUNT_360,
        "_360_user_pw"       : project.PASSWORD_360,

        //签名文件配置, 使用空字符, 会自动赋值. (可选)
        "keystorePath"       : '',
        "keystorePwd"        : '',
        "keystoreAlias"      : '',
        "keystoreAliasPwd"   : '',

        //需要加固的APK路径, 如果不存在任务中断执行, 为空:自动根据Gradle配置获取路径 (可选)
        "targetApkPath"      : "",

        //自动查找`targetApkPath`时, 取名字中包含`likeApkName`字符串的路径, 如果有多个, 取第一个
        "likeApkName"        : "",

        //文件所在的根目录
        "root_path"          : projectPath + "/" + folder_name,
        //首次下载360加固的临时存放目录
        "download_jiagu_path": projectPath + "/" + folder_name + "/download",

        //360加固文件所在的根目录
        "jiagu_root_path"    : projectPath + "/" + folder_name + "/jiagu",
        "walle_root_path"    : projectPath + "/" + folder_name + "/walle",

        //渠道文件信息路径
        "channelList"        : projectPath + "/" + folder_name + "/walle/channel",

        //渠道分包后的APK文件名,为空:自动从Gradle脚本中获取 (可选)
        "tmpApkName"         : "",

        //最终生成zip包的文件名 (可选)
        "zipFileName"        : "",

        //360加固jar文件路径
        "jiaguJarPath"       : projectPath + "/" + folder_name + "/jiagu/jiagu.jar",
        //walle分包jar文件路径
        "walleJarPath"       : projectPath + "/" + folder_name + "/walle/walle-cli-all.jar",
        //临时文件输出目录
        "tmpOutput"          : projectPath + "/" + folder_name + "/output/tmp",
        //zip文件输出目录
        "zipOutput"          : projectPath + "/" + folder_name + "/output/zip",
        //加固后文件输出目录
        "jiaguOutput"        : projectPath + "/" + folder_name + "/output/jiagu",
        //walle分包输出目录
        "walleOutput"        : projectPath + "/" + folder_name + "/output/walle",

]

def getSysyemJiaGuPath() {
    def osName = System.getProperty("os.name").toLowerCase()
    color_print "当前操作系统:" + osName
    if (osName.indexOf("mac") >= 0 && osName.indexOf("os") > 0) {
        return "jiagu_mac1"
    } else if (osName.indexOf("window") >= 0) {
        return "jiagu_win1"
    } else {
        throw new RuntimeException("当前操作系统:" + osName + " not support,请集成相关系统的360加固文件")
    }
}
//获取apk路径和文件名称
project.afterEvaluate {
//    tasks.getByName()
//    project.android.applicationVariants.all { variant ->

//        println("获取打包的apk路径:"+variant.name.toLowerCase())
//        if (
//        (jiaguConfig.likeApkName == "" && variant.name.toLowerCase().endsWith("release"))
//                || (jiaguConfig.likeApkName != "" && variant.name.toLowerCase().contains(jiaguConfig.likeApkName))
//        ) {
//            if (jiaguConfig.keystorePath == '') {
//                //自动配置签名信息
//                jiaguConfig.keystorePath = variant.signingConfig.storeFile
//                jiaguConfig.keystorePwd = variant.signingConfig.storePassword
//                jiaguConfig.keystoreAlias = variant.signingConfig.keyAlias
//                jiaguConfig.keystoreAliasPwd = variant.signingConfig.keyPassword
//
//
//                List<String> list = new ArrayList<>()
//                list.add('-importsign')
//                list.add(jiaguConfig.keystorePath)
//                list.add(jiaguConfig.keystorePwd)
//                list.add(jiaguConfig.keystoreAlias)
//                list.add(jiaguConfig.keystoreAliasPwd)
//
//                println "使用签名:" + list
//
//                setKeystore.setArgs(list)
//            }
//
//            variant.outputs.each { output ->
//                //自动配置目标文件路径, 和临时文件名
//                if (jiaguConfig.targetApkPath == "") {
//                    jiaguConfig.targetApkPath = output.outputFile.getAbsolutePath()
//                    println "读取到目标apk路径:" + jiaguConfig.targetApkPath
//                }
//
//                if (jiaguConfig.tmpApkName == '') {
//                    jiaguConfig.tmpApkName = output.outputFile.getName()
//                    println "临时文件名:" + jiaguConfig.tmpApkName
//                }
//                copyTmpApk.rename('(.+)', jiaguConfig.tmpApkName)
//
//                if (jiaguConfig.zipFileName == '') {
//                    jiaguConfig.zipFileName = jiaguConfig.tmpApkName
//                            .substring(0, jiaguConfig.tmpApkName.lastIndexOf('.')) + ".zip"
//                    println "zip文件名:" + jiaguConfig.zipFileName
//                }
//
//                zipChannel.archiveName = jiaguConfig.zipFileName
//
//                //重置加固task参数
//                List<String> list = new ArrayList<>()
//                list.add('-jiagu')
//                list.add(jiaguConfig.targetApkPath)
//                list.add(jiaguConfig.jiaguOutput)
//                list.add('-autosign')
//                jiagu360.setArgs(list)
//
//                //重置walle task参数
//                list = new ArrayList<>()
//                list.add('batch')
//                list.add('-f')
//                list.add(jiaguConfig.channelList)
//                list.add(jiaguConfig.tmpOutput + File.separator + jiaguConfig.tmpApkName)
//                list.add(jiaguConfig.walleOutput)
//                walleApk.setArgs(list)
//            }
//        }
//    }
}

// 进行登录
task login(type: JavaExec, dependsOn: 'assembleRelease') {
    workingDir(jiaguConfig.jiagu_root_path)
    classpath(files(jiaguConfig.jiaguJarPath))
    main('com.qihoo.jiagu.CmdMain')
    args('-login', jiaguConfig._360_user_name, jiaguConfig._360_user_pw)
}

//设置签名配置
task setKeystore(type: JavaExec, dependsOn: login) {
    workingDir(jiaguConfig.jiagu_root_path)
    classpath(files(jiaguConfig.jiaguJarPath))
    main('com.qihoo.jiagu.CmdMain')
}

//显示签名信息
task showKeystore(type: JavaExec) {
    workingDir(jiaguConfig.jiagu_root_path)
    classpath(files(jiaguConfig.jiaguJarPath))
    main('com.qihoo.jiagu.CmdMain')
    args('-showsign')
}

//进行加固
task jiagu360(type: JavaExec, dependsOn: setKeystore) {
    workingDir(jiaguConfig.jiagu_root_path)
    classpath(files(jiaguConfig.jiaguJarPath))
    main('com.qihoo.jiagu.CmdMain')
    //动态设置args
//    args('-jiagu',
//            tmpInputPath + File.separator + tmpInputApkFile,
//            jiaguOutput,
//            '-autosign')
}

//加固后的包保留,拷贝一份在tmp里面玩
task copyTmpApk(type: Copy, dependsOn: jiagu360) {
    from(jiaguConfig.jiaguOutput)
    //include('*_jiagu_sign.apk')
    include('*.apk')
    into(jiaguConfig.tmpOutput)
    //名余曰正则兮，字余曰灵均, 动态执行
    //rename('(.+)', tmpApk)
}

//瓦力打包
task walleApk(type: JavaExec, dependsOn: copyTmpApk) {
    workingDir(jiaguConfig.walle_root_path)
    classpath(files(jiaguConfig.walleJarPath))
    main('com.meituan.android.walle.Main')
    //动态设置args
//    args('batch', '-f',
//            baseBuildPath + channelList,
//            tmpPath + File.separator + tmpApk,
//            wallePath)
}

task zipChannel(type: Zip, dependsOn: walleApk) {
    //workingDir(baseBuildPath)
    from(jiaguConfig.walleOutput)
    //动态设置
    archiveName(jiaguConfig.zipFileName)
    destinationDir file(jiaguConfig.zipOutput)
}

task _360jiagu(dependsOn: zipChannel) {
    doLast {
        color_print "加固结束:"
        color_print("渠道包路径:" + jiaguConfig.walleOutput)
        color_print("zip包路径:" + jiaguConfig.zipOutput)
    }
}

login.doFirst {
    File targetFile = new File(jiaguConfig.targetApkPath)
    if (!targetFile.exists()) {
        throw new RuntimeException("加固文件不存在:" + targetFile.getAbsolutePath())
    } else {
        color_print("开始加固:" + targetFile.getAbsolutePath())
        color_print("输出zip路径:" + jiaguConfig.zipOutput)
    }
    //创建基础文件夹
    createFolder(jiaguConfig.walleOutput, true)
    createFolder(jiaguConfig.zipOutput)
    createFolder(jiaguConfig.jiaguOutput, true)
    createFolder(jiaguConfig.tmpOutput, true)
}
login.doFirst {
    //初始化相关路径信息  签名信息
    project.android.applicationVariants.all { variant ->
        //对应app/build.gradle文件声明 buildTypes 下声明的打包类型
        color_print("打包方式：" + variant.name.toLowerCase())
        if (
        (jiaguConfig.likeApkName == "" && variant.name.toLowerCase().endsWith("release"))
                || (jiaguConfig.likeApkName != "" && variant.name.toLowerCase().contains(jiaguConfig.likeApkName))
        ) {
            if (jiaguConfig.keystorePath == '') {
                //自动配置签名信息
                jiaguConfig.keystorePath = variant.signingConfig.storeFile
                jiaguConfig.keystorePwd = variant.signingConfig.storePassword
                jiaguConfig.keystoreAlias = variant.signingConfig.keyAlias
                jiaguConfig.keystoreAliasPwd = variant.signingConfig.keyPassword


                List<String> list = new ArrayList<>()
                list.add('-importsign')
                list.add(jiaguConfig.keystorePath)
                list.add(jiaguConfig.keystorePwd)
                list.add(jiaguConfig.keystoreAlias)
                list.add(jiaguConfig.keystoreAliasPwd)

                color_print "使用签名:" + list

                setKeystore.setArgs(list)
            }

            variant.outputs.each { output ->
                //自动配置目标文件路径, 和临时文件名
                if (jiaguConfig.targetApkPath == "") {
                    jiaguConfig.targetApkPath = output.outputFile.getAbsolutePath()
                    color_print "读取到目标apk路径:" + jiaguConfig.targetApkPath
                }

                if (jiaguConfig.tmpApkName == '') {
                    jiaguConfig.tmpApkName = output.outputFile.getName()
                    color_print "临时文件名:" + jiaguConfig.tmpApkName
                }
                copyTmpApk.rename('(.+)', jiaguConfig.tmpApkName)

                if (jiaguConfig.zipFileName == '') {
                    jiaguConfig.zipFileName = jiaguConfig.tmpApkName
                            .substring(0, jiaguConfig.tmpApkName.lastIndexOf('.')) + ".zip"
                    color_print "zip文件名:" + jiaguConfig.zipFileName
                }

                zipChannel.archiveName = jiaguConfig.zipFileName

                //重置加固task参数
                List<String> list = new ArrayList<>()
                list.add('-jiagu')
                list.add(jiaguConfig.targetApkPath)
                list.add(jiaguConfig.jiaguOutput)
                list.add('-autosign')
                jiagu360.setArgs(list)

                //重置walle task参数
                list = new ArrayList<>()
                list.add('batch')
                list.add('-f')
                list.add(jiaguConfig.channelList)
                list.add(jiaguConfig.tmpOutput + File.separator + jiaguConfig.tmpApkName)
                list.add(jiaguConfig.walleOutput)
                walleApk.setArgs(list)
            }
        }
    }
}

/**创建路径*/
def createFolder(String path, boolean clear = false) {
    File folder = file(path)
    if (folder.exists()) {
        if (clear) {
            clearFolder(path)
        }
    } else {
        folder.mkdirs()
    }
}

/**清理文件夹*/
def clearFolder(String path) {
    File folder = file(path)
    for (File f : folder.listFiles()) {
        if (f.isDirectory()) {
            clearFolder(f.getAbsolutePath())
        } else if (f.isFile()) {
            color_print "删除文件:" + f + " " + f.delete()
        }
    }
}

/**自动读取签名配置信息 因会出现获取不到签名，需手动导入的情况，故每次直接从gradle中声明的位置获取，此方法暂时废弃*/
def readSigning() {
    def application = "com.android.application"
    def applicationPlugin = project.plugins.findPlugin(application)
    //applicationPlugin.extension
    //color_print "插件:" + applicationPlugin
    //color_print applicationPlugin.extension.signingConfigs[0]
    def signingConfigs = applicationPlugin.extension.signingConfigs

    def signingMap = new HashMap<String, String>()

    if (signingConfigs.size() > 0) {
        def builder = new StringBuilder()
        builder.append("找到签名配置" + signingConfigs.size() + "个\n")
        signingConfigs.each {
            builder.append("name:")
            builder.append(it.name)
            builder.append("\n")

            builder.append("mStoreFile:")
            builder.append(it.storeFile)
            builder.append("\n")

            builder.append("mStorePassword:")
            builder.append(it.storePassword)
            builder.append("\n")

            builder.append("mKeyAlias:")
            builder.append(it.keyAlias)
            builder.append("\n")

            builder.append("mKeyPassword:")
            builder.append(it.keyPassword)
            builder.append("\n")
            builder.append("\n")

            signingMap.put("sf", it.storeFile)
            signingMap.put("sp", it.storePassword)
            signingMap.put("kp", it.keyPassword)
            signingMap.put("ka", it.keyAlias)
        }
        color_print builder
    } else {
        color_print "未找到签名配置信息"
    }

    return signingMap
}

project.tasks.whenTaskAdded { Task theTask ->
    if (theTask.name == 'assembleBeta') {
        theTask.doLast {
            _uploadApp()
        }           // 编译完apk之后再执行自定义task
    }
}
//上传prerelease包至蒲公英
def _uploadApp() {
    project.android.applicationVariants.all { variant ->
        //对应app/build.gradle文件声明 buildTypes 下声明的打包类型
        color_print("打包方式：" + variant.name.toLowerCase())
//        if(tasks.getByName())
        if (variant.name.toLowerCase().endsWith("beta")) {
            variant.outputs.each { output ->
                color_print "上传蒲公英---读取到目标apk路径:" + output.outputFile.getAbsolutePath()
                File dir = new File(output.outputFile.getAbsolutePath())
                if (!dir.exists()) {
                    throw new RuntimeException("上传蒲公英---目标apk路径 not exists：" + dir.path)
                }
                uploadPGY(dir.path)
            }
        }
    }

}
/*
*上传apk到蒲公英
*/

private def uploadPGY(String filePath) {
    color_print "uploadPGY filePath：" + filePath
    def stdout = new ByteArrayOutputStream()
    exec {
        executable = 'curl'
        args = ['-F', "file=@${filePath}", '-F', "_api_key=${rootProject.ext.pgy["apiKey"]}", rootProject.ext.pgy["uploadUrl"]]
        standardOutput = stdout
    }
    String output = stdout.toString()
    def parsedJson = new JsonSlurper().parseText(output)
    color_print "✈ ❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤上传成功❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤ ✈"
    color_print "App的名称：" + parsedJson.data.buildFileName
    color_print "App版本号：" + parsedJson.data.buildVersion
    color_print "App版本号：" + parsedJson.data.buildVersionNo
    color_print "AppBuildVersion：" + parsedJson.data.buildBuildVersion
    color_print "App包体积：" + parsedJson.data.buildFileSize
    color_print "App短链接：https://www.pgyer.com/" + parsedJson.data.buildShortcutUrl
    color_print "App下载页地址：https://www.pgyer.com/" + parsedJson.data.buildKey
    color_print "App二维码地址：" + parsedJson.data.buildQRCodeURL
    color_print "App上传时间：" + parsedJson.data.buildCreated
    color_print "✈ ❤❤❤❤❤❤❤❤❤❤❤❤❤❤信息打印完毕❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤ ✈"
}

/**
 * 彩色日志打印
 * printf("\033[字背景颜色;字体颜色m 字符串 \033[0m" );
 * @param value
 * @return
 */
def color_print(String value) {
    printf "\033[1;32m%s\033[0m\n", value
}


// 解压缩第三方jar包到某目录
task unzip(type: Copy) {

    // 原始jar包文件
    def zipFile = file(projectPath + "/" + folder_name + "/output/zip/auto_pack_1.0_release.zip")

    // 解压缩目标目录
    def outputDir = file(projectPath + "/" + folder_name + "/output/zip")

    // 文件过滤，去除部分class。这里建议写精确点，因为可能存在名称相同或相近的文件。
    FileTree jarTree = zipTree(zipFile)

    // 从jar的目录树中输出到目标目录
    from jarTree
    into outputDir
}

task downloadZipFile(type: Download) {
    src getJiaGuZipUrlByOs()
    dest new File(jiaguConfig.download_jiagu_path, '360jiagubao.zip')
    overwrite false
    doLast {
        color_print "✈✈✈✈✈✈✈360加固资源包下载完成 准备进行解压 请稍后。。。"
    }
}
task downloadAndUnzipFile(dependsOn: downloadZipFile, type: Copy) {
    from zipTree(downloadZipFile.dest)
    into jiaguConfig.download_jiagu_path
    doLast {
        File folder = file(jiaguConfig.download_jiagu_path)
        for (File f : folder.listFiles()) {
//            if (f.isFile()) {
                color_print "解压出的文件:" + f
//            }
        }
        color_print "✈✈✈✈✈✈✈解压完成  准备将解压出来的jiagu文件夹复制到"+jiaguConfig.root_path+"文件夹下 请稍后。。。"
    }
}
task moveDownloadJiaGu(dependsOn: downloadAndUnzipFile, type: Copy) {
    //下载的360加固zip解压出的jiagu文件家路径
    def downnload_jiagu = jiaguConfig.download_jiagu_path+"/jiagu"
    doFirst {
        File folder = file(downnload_jiagu)
        if(!folder.exists()){
            File file1 = new File(jiaguConfig.download_jiagu_path)
            if (file1.exists()){
                file1.deleteDir()
            }
            File file2 = new File(jiaguConfig.jiagu_root_path)
            if (file2.exists()){
                file2.deleteDir()
            }
            throw new RuntimeException("没有在解压的文件夹中找到jiagu文件夹，请手动请去官网下载对应的资源包，解压到：" + jiaguConfig.root_path +"文件夹下")
        }
    }
    from downnload_jiagu
    into jiaguConfig.jiagu_root_path
    doLast {
        color_print "✈✈✈✈✈✈✈复制完成。。。"
        File file1 = new File(jiaguConfig.download_jiagu_path)
        file1.deleteDir()
        color_print "✈✈✈✈✈✈✈删除下载的加固压缩包源文件"

    }
}

task _Test {
    check()
}

def check() {
    color_print "✈✈✈✈✈✈✈开始检测360加固文件夹是否存在✈✈✈✈✈✈✈"
    File folder = file(jiaguConfig.jiagu_root_path)
//    clearFolder(jiaguConfig.jiagu_root_path)
//    folder.delete()
//    folder = file(jiaguConfig.jiagu_root_path)
    if (folder.exists()) {
        color_print "✈✈✈✈✈✈✈360加固文件夹存在✈✈✈✈✈✈✈"
//        tasks.getByName("_Test").dependsOn(ass)
    } else {
        color_print "✈✈✈✈✈✈✈360加固文件夹不存在，进行创建✈✈✈✈✈✈✈"
//        folder.mkdirs()
//        color_print "✈✈✈✈✈✈✈文件夹创建成功："+folder.path
        color_print "✈✈✈✈✈✈✈开始执行下载加固压缩包 请稍后。。。"
        tasks.getByName("_Test").dependsOn(moveDownloadJiaGu)
    }
}


def getJiaGuZipUrlByOs() {
    def url
    String osName = org.gradle.internal.os.OperatingSystem.current().getName();
    String osVersion = org.gradle.internal.os.OperatingSystem.current().getVersion();
    color_print "*** $osName $osVersion was detected."

    if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        url = rootProject.ext.URL_JIAGU_ZIP_360["linux"]
    } else if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
        url =  rootProject.ext.URL_JIAGU_ZIP_360["windows"]
    } else if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        url =  rootProject.ext.URL_JIAGU_ZIP_360["mac"]
    }else {
        throw new RuntimeException("不支持当前操作系统：" + osName )
    }
    color_print "根据当前系统获得要下载360加固包的链接地址为："+url
    return url
}
